---
title: "Simulations"
author: "Will Pfadenhauer and Grace DiRenzo"
date: "2023-09-25"
output: html_document
---
##Load packages
```{r}
require(data.table)
require(MASS)
require(ggplot2)
```

We need to simulate data that has a dispersion parameter of 2.1 (ish)

Here's the model that had the issue - sub-model #1 from SEMS_Native.Rmd file.
                glm.nb(Native_species ~ 
                       Maximum_elevation_ft +
                       distance_continent_10km +
                       Max_temp_deg_C_BIO5,
                       data = data)

This won't run here since we haven't loaded the data object. We don't need to run it - just to see the structure.

##Create islands and covariates
So we need several continuous explanatory variables.
```{r}
#Number of islands - matches our dataset
n.islands <- 46

set.seed(345) #Change this to whatever - just want to make sure final results are consistent and replicable

#Create some data that roughly matches the structure of the existing variables in sub-model 1 (above)
dat <- data.frame(Maximum_elevation_ft = rpois(n = n.islands, lambda = 4224),
                  distance_continent_10km = rgamma(n.islands, shape = 0.92, rate = 0.005),
                  Max_temp_deg_C_BIO5 = rnorm(n.islands, mean =30, sd=6))

```

##Specify beta parameters
Now we need to set parameters for those variables. I'm going to take the ones that were generated by 
sub-model 1 in the SEMS_Native.Rmd file. 
```{r}
beta_elev <- 0.0002
beta_dist <- -0.0029
beta_temp <- 0.1758
```

##Create response variable
Now we need a response variable (derived from the explanatory variables) that's overdispersed count data. 

Let's set up the equation for a negative binomial response variable that is a function of our predictor variables.
```{r}
native_eqn <- exp((beta_elev * dat$Maximum_elevation_ft)+
                          (beta_dist * dat$distance_continent_10km) + 
                          (beta_temp * dat$Max_temp_deg_C_BIO5))

#Very simply, this is the structure of a negative binomial equation - it's essentially the same as a linear equation, but the whole thing is exp-ed
```

Now, let's use the native equation to actually generate our response variable. 

rnbinom() function generates simulated data using the negative binomial distribution. 
n = number of islands
size = dispersion parameter
mu = estimates created using the data and coefficients we created above
```{r}
#Now, the size variable here will actually determine the dispersion parameter (obviously with some variability built in).
set.seed(345) #Change this to whatever - just want to make sure final results are consistent and replicable
dat$Native_species <- rnbinom(n= n.islands, size = 3, mu=native_eqn)
```

##Fit the observed model
Now let's fit the model 
```{r}
sim1 <-   glm.nb(Native_species ~ 
                       Maximum_elevation_ft +
                       distance_continent_10km +
                       Max_temp_deg_C_BIO5,
                       data = dat)

summary(sim1)
#Note the dispersion parameter here (theta)
```

##Compare model to true values
Let's compare the model-estimated coefficients to the true values. 
This chunk just extracts the results from our model above. 
```{r}
compare.dat <- data.frame(
  
  truth = c(beta_elev, beta_dist, beta_temp),
  
  names = c("beta_elev", "beta_dist", "beta_temp"),
  
  sim1.mean = c(
    
    coef(sim1)[names(coef(sim1)) == "Maximum_elevation_ft"],
    coef(sim1)[names(coef(sim1)) == "distance_continent_10km" ],
    coef(sim1)[names(coef(sim1)) == "Max_temp_deg_C_BIO5"]
  ),
  
  sim1.q2.5 = c(
    
    confint(sim1)[rownames(confint(sim1)) == "Maximum_elevation_ft", 1],
    confint(sim1)[rownames(confint(sim1)) == "distance_continent_10km", 1],
    confint(sim1)[rownames(confint(sim1)) == "Max_temp_deg_C_BIO5", 1]
  ),
  
  sim1.q97.5 = c(
    
    confint(sim1)[rownames(confint(sim1)) == "Maximum_elevation_ft", 2],
    confint(sim1)[rownames(confint(sim1)) == "distance_continent_10km", 2],
    confint(sim1)[rownames(confint(sim1)) == "Max_temp_deg_C_BIO5", 2]
  ))
```

##Plot results
This chunk just plots the extracted results from above. 
```{r}
# Set colors for truth and estimates
cols <- c("Truth" = "red", "Estimated" = "black")

# Make the plot
ggplot(compare.dat, aes(x= names, y=sim1.mean, ymin=sim1.q2.5, ymax=sim1.q97.5))+ 
  geom_linerange(linewidth = 1) +
  geom_point(size = 3, aes(x = names, y = sim1.mean, col = "Estimated")) +
  geom_point(size = 3, aes(x = names, y = truth, col = "Truth")) +
  scale_colour_manual("Values", values=cols)+
  geom_hline(yintercept = 0, lty=2) +
  coord_flip() + ylab('Parameter estimates') +
  xlab("Parameter names") +
  theme_bw()+ 
  theme(axis.text.x = element_text(size = 17, color = "black"), 
        axis.text.y = element_text(size = 17, color = "black"), 
        axis.title.y = element_text(size = 17, color = "black"), 
        axis.title.x =element_text(size = 17, color = "black"),
        legend.title =element_text(size = 17, color = "black"),
        legend.text =element_text(size = 17, color = "black"),
        panel.grid.major = element_blank(), 
        panel.grid.minor = element_blank()) 
```
Even with a dispersion parameter of 3.1 (ours was only 2.1) we still see that the true value of all of the coefficients still fall within the estimated confidence intervals from the model. 

So it's safe to conclude that a slightly elevated dispersion parameter isn't invalidating our results. 

Another good check is to change the size parameter above to something closer to 1 (instead of 3) and then run all the code again - notice that the results are nearly identical. 




